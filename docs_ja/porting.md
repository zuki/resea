# 別のCPUアーキテクチャへのポーティング

新しいCPUアーキテクチャ（短く*arch*）へのポーティングはそのアーキテクチャについて
熟知していればとても簡単です。

1. *example*アーキテクチャを使って新しいポートの骨組みを作成します。
  `libs/common/arch/example`, `kernel/arch/example`, `libs/resea/arch/example`
2. アーキテクチャ固有の型を定義し、`common`ライブラリの設定をします。
3. カーネルのためのHAL(ハードウェア抽象レイヤ）を実装します。
4. `resea`ライブラリのアーキテクチャ固有の部分を実装します。
5. `Kconfig`にアーキテクチャを追加します。

## `common`ライブラリを実装する

共通ライブラリ (`libs/common`) はスタンドアロンライブラリ（双方向リンクリストなど）
とカーネルとユーザ空間プログラム相応のための型の提供を担当します。次のファイルを
実装する必要があります。

- `libs/common/arch/<arch-name>/arch.mk`
  - アーキテクチャのためのオプションを構築します: `$CFLAGS`, `run` コマンドなど
- `libs/common/arch/<arch-name>/arch_types.h`
  - アーキテクチャ固有の`#define`と`typedef`

## カーネルを移植する

ポータビリティのためにカーネルはアーキテクチャ固有のレイヤ
（*ハードウェア抽象レイヤ*）を`kernel/arch`に分離しています。

大雑把に言うと、以下の実装が必要です。

- CPUの初期化
- シリアルポートドライバ（`print`関数のため）
- コンテキストスイッチ
- 仮想メモリ管理（ページテーブルの更新と切り替え）
  - Reseaカーネルは仮想メモリを実装しないCPUのために`NOMMU`モードもサポートしています。
- 割込み/例外/システムコールのハンドラ
- カーネル実行ファイルのためのリンカスクリプト (`kernel/arch/<arch-name>/kernel.ld`)
- マルチプロセッサのサポート *(オプション)*

## `resea`ライブラリを実装する

`resea`ライブラリはユーザ空間アプリケーションのための標準ライブラリです。
以下の実装が必要です。

- `syscall()`関数
- ユーザ空間プログラムのためのリンカスクリプト (`libs/resea/arch/<arch-name>/user.ld`)
- プログラムのエントリポイント: スタックポインタを初期化して、`resea_init()`を呼び出す。
- Bootfsのサポート。BootfsはReseaのためのシンプルなファイルシステムイメージ（tarファイルと
  同じ）です。Reseaはこのファイルから最初のユーザ空間プログラムを起動します。bootfs
  ヘッダを埋め込むための空間を作成する必要があります。具体的な例は
  `libs/resea/arch/x64/start.S`を参照してください。
