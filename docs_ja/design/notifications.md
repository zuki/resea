# 通知

メッセージの送受信はブロック操作であり、ほとんどの場合でうまく動きますが、
非同期な方法でメッセージを送信する必要がある場合もあります。

*通知*は非同期（ノンブロッキング）なIPC機構であり、単に宛先タスクの通知フィールドを
更新（ビット単位OR）するだけです。タスクがメッセージを受信しようとする際、カーネルは
まず保留中（未受信）の通知がないかチェックし、もしあれば、カーネルはそれを
メッセージとして返します。

（まさにUNIXの*シグナル*のように）**通知IPCは単なるビットフィールドの更新である**
ことに注意してください。同じ通知が何回通知されたかを知ることはできません。

## 通知はなぜ必要ですか?

たとえば、TCP/IPサーバとそのデバイスドライバを設計しているとしましょう。

```
             パッケージが到着したら
             メッセージを送信する
   Device  ----------------------->  TCP/IP
   Driver                            Server
     ^                                |
     |                                |
     +--------------------------------+
       パッケージを送信するためのメッセージを送信する
```

直感的なアプローチに見えますが、TCP/IPサーバがドライバーにメッセージを送信しようと
しているときに、デバイスドライバがネットワークパケットを送信しようとしたらどう
なるでしょうか。IPCの操作はブロックされるのでデッドロックの原因になる可能性があります。

Reseaのアプリケーションを書く際に最も重要なことは[QNXのIPCドキュメント](http://www.qnx.co.jp/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_sys_arch%2Fipc.html)に
書いてあるように**2つのタスクが互いにメッセージを送信してはならない**ということです。

Reseaでデッドロックを回避するにはどうすればよいのでしょうか。ここで、通知の出番と
なります。

## Notify & Pullパターン

互いにメッセージを送信するのではなく、何らかのデータをドライバに送る際に、TCP/IPは
保留中のデータがあることをドライバに非同期に*通知*します。この通知を受け取ったデバイス
ドライバはメッセージパッシング経由で保留データを取り込みます。

```
            2. 送信パッケットを
             リクエストして受信する
   Device  ----------------------->  TCP/IP
   Driver                            Server
     ^                                .
     .                                .
     ..................................
         1. 新しいデータがあることを
          非同期に通知する
```

詳細は[非同期IPC](../userspace/async-message-passing.html)を参照してください。
